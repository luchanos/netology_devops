1. Какой системный вызов делает команда cd?

В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace
 непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте.

Вам нужно найти тот единственный, который относится именно к cd. 
Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.

- Судя по всему этот системный вызов выглядит вот так - ```chdir("/home/vagrant/Desktop")```

2. Попробуйте использовать команду file на объекты разных типов в файловой системе. Например:
```
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
```
Используя strace выясните, где находится база данных file, на основании которой она делает свои догадки.

- Вижу вот такую строчку - ```openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3``` и вот эта магическая штука,
как я почитал в интернетах и есть база данных со знаниями

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности
сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. 
Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. 
Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного 
файла (чтобы освободить место на файловой системе).

- Можно попробовать действовать так: у нас есть файловые дескрипторы, которые можно будет найти в /proc/PID/fd/. 
Отыскиваем дескриптор удаленного файла и перенаправляем его вывод куда-нибудь ещё. А по поводу транкейта удаленного
файла нашел решение вот тут - https://unix.stackexchange.com/questions/68523/find-and-remove-large-files-that-are-open-but-have-been-deleted
Несмотря на то, что в lsof файла больше нет мы можем сделать ```find /proc/*/fd -ls | grep  '(deleted)'``` и дальше
запустить ```: > "/proc/$pid/fd/$fd"``` с номером полученного на предыдущем шаге pid

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

- по сути они ничего не занимают, посколькую это просто запись в запись в таблице процессов. Разве что это можно назвать "занятием" места.

5. 