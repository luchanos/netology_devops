1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если считаете, что она могла бы быть другого типа.

- Для начала стоит понять то, какого типа бывают команды. И вообще - что такое тип. Я помню, что каждая команда, по сути, это обращение к какой-то
программе в Linux, а в Linux всё является файлами, которые распиханы по разным папкам. Соответственно каждая папка - это тип.
Для начала можно начать с тог, что ввести в терминал команду ```type cd``` и получить вывод ```cd is a shell builtin```.
То есть это встроенная команда shell. Введя команду ```type -a cd``` получим еще и путь ```cd is /usr/bin/cd```
У нас получается, что cd - это исполняемый файл встроенной команды. Можно ещё почитать про cd через man - там
написано, что это встроенная команда.

Если бы cd была бы не встроенной, то она была бы не в папке usr/bin, а лежала бы в usr/local/bin.

2. Какая альтернатива без pipe команде ```grep <some_string> <some_file> | wc -l```?

- wc - утилита для анализа файлов. wc -l выводит количество строк в объекте. grep строки в файле отыскивает кусок, 
где располагается искомая подстрока. Альтернатива: ```grep -c "≤подстрока≥" <путь_к_файлу>```

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
```Процесс называется systemd```

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
- Пока экспериментировал - проклял всё) В общем получилось вот так: ```ls 2>tty2``` или в папке dev/pts
вводим ```ls 2>2```. Предварительно открыл новый терминал и запросил через ps как он называется. Можно ещё 
посмотреть на псевдотерминал.

6. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? 
Приведите работающий пример.

```tail 2.txt >> result.txt```

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? 
Сможете ли вы наблюдать выводимые данные?
- Не понял вопроса, потому что PTY является одним их подвидов TTY. Разумеется мы можем выводить данные посредством 
перенаправления потока вывода / вывода / ошибок, как делали в предыдущих примерах.

7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните 
echo netology > /proc/$$/fd/5? Почему так происходит?

- Тут дело такое - мы создали 5 дескриптор, который смотрит в stdout нашего процесса. Соответственно когда мы пишем
эхо нетологии и прописываем адрес к новому дескриптору, то попав туда информация появляется на 1 дескрипторе, который
является стандартным выводом для нашей консоли.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при 
этом отображение stdout на pty?
Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. 
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились
создавать в предыдущем вопросе.

- Ну судя по формулировке задания - получится. Надо создать новый дескриптор или использовать 5 из прошлого задания:
- сначала пишем ```echo 1>&0``` теперь вывод смотрит на ввод.
- дальше пишем ```echo 0>&5``` теперь ввод смотрит на то, что в 5м дескрипторе, а там вывод.

9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

- Получили содержание файла с переменными окружения. По идее можно было просто вызвать env команду.

10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
- cmdline хранит все переданные в консоль аргументы с момента, когда она была запущена
- exe хранит ссылку на актуальную запущенную команду. Там ещё пишут что можно с её помощью запустить точно такую же.

11.Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

- сделал grep sse по cpuinfo и увидел что 4.2

12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty.
Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.
Однако:
```
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```
Почитайте, почему так происходит, и как изменить поведение.
- https://unix.stackexchange.com/questions/48527/ssh-inside-ssh-fails-with-stdin-is-not-a-tty
- умный человек пишет о том, что при создании remote подключения по ssh у нас не аллоцируется tty
- чтобы все было ок, надо добавить флаг -t, чтобы получилось: ```ssh -t localhost 'tty'```

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. 
Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, 
который вы запустили по ошибке в обычной SSH-сессии.
- Окей, попробовал - создал в фоне ping процесс на локалхост в одном терминале и попробовал своровать его 
в другом. Получилось не сразу.
14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, 
так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. 
Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. 
Узнайте? что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
- команда tee позволяет перенаправлять выходной материал команды в переменную или в файл, почитал Вики на эту тему. А 
что касается почему в первом случае не работает, а во втором - работает: в первом мы делаем с суперюзером echo команду,
но вот записывать в рут продолжаем под обычным. А во втором примере мы как раз читать можем и под обычным пользователем,
а вот через tee под суперюзером имеем возможность записывать в файл.